# FDTDé€±æœŸé‚Šç•Œæ¢ä»¶è¨ºæ–·å·¥å…·

import numpy as np
import matplotlib.pyplot as plt

def diagnose_pbc_implementation(grid, grid_spacing):
â€œâ€â€
å°æ¯”MATLABç¬¬14ç« å¯¦ç¾ï¼Œè¨ºæ–·é€±æœŸé‚Šç•Œæ¢ä»¶çš„å•é¡Œ
â€œâ€â€

```
print("ğŸš¨ FDTDé€±æœŸé‚Šç•Œæ¢ä»¶è¨ºæ–·")
print("="*80)

# === 1. åŸºæœ¬é…ç½®æª¢æŸ¥ ===
print("1. åŸºæœ¬é…ç½®å°æ¯”ï¼š")
print("   MATLABç¬¬14ç«  vs æ‚¨çš„å¯¦ç¾")
print("   " + "-"*50)

# æª¢æŸ¥ç¶²æ ¼é…ç½®
print(f"   ç¶²æ ¼å½¢ç‹€: {grid.shape}")
print(f"   force_complex: {getattr(grid, 'force_complex', False)}")

# æª¢æŸ¥é‚Šç•Œæ¢ä»¶é¡å‹
boundary_types = []
for boundary in grid.boundaries:
    boundary_types.append(type(boundary).__name__)
print(f"   é‚Šç•Œé¡å‹: {boundary_types}")

# === 2. é€±æœŸé‚Šç•Œå¯¦ç¾æª¢æŸ¥ ===
print(f"\n2. é€±æœŸé‚Šç•Œå¯¦ç¾æª¢æŸ¥ï¼š")

has_bloch = any('Bloch' in str(type(b)) for b in grid.boundaries)
has_periodic = any('Periodic' in str(type(b)) for b in grid.boundaries)

print(f"   æœ‰Bloché‚Šç•Œ: {has_bloch}")
print(f"   æœ‰Periodicé‚Šç•Œ: {has_periodic}")

if has_bloch:
    for b in grid.boundaries:
        if 'Bloch' in str(type(b)):
            print(f"   Blochåƒæ•¸: k_component={getattr(b, 'k_component', 'N/A')}")
            print(f"              length={getattr(b, 'length', 'N/A')}")
            print(f"              phase={getattr(b, 'phase', 'N/A')}")

# === 3. æºå¯¦ç¾æª¢æŸ¥ ===
print(f"\n3. æºå¯¦ç¾æª¢æŸ¥ï¼š")

for i, src in enumerate(grid.sources):
    src_type = type(src).__name__
    print(f"   æº{i}: {src_type}")
    
    if hasattr(src, 'theta_deg'):
        print(f"         å…¥å°„è§’: {src.theta_deg}Â°")
    if hasattr(src, 'wavelength'):
        print(f"         æ³¢é•·: {src.wavelength*1e9:.0f} nm")
    if hasattr(src, 'polarization_axis'):
        print(f"         æ¥µåŒ–: {src.polarization_axis}")

# === 4. é—œéµå·®ç•°è­˜åˆ¥ ===
print(f"\n4. èˆ‡MATLABç¬¬14ç« çš„é—œéµå·®ç•°ï¼š")
print("   " + "-"*50)

issues = []

# å·®ç•°1: æºé¡å‹
matlab_uses_pbc_source = True  # MATLABç”¨ç‰¹æ®Šçš„PBCæº
python_uses_complex_plane_wave = any('ComplexPlaneWave' in str(type(s)) for s in grid.sources)

if not python_uses_complex_plane_wave:
    issues.append("âŒ æœªä½¿ç”¨è¤‡æ•¸å¹³é¢æ³¢æº")
    print("   âŒ æºé¡å‹å·®ç•°:")
    print("      MATLAB: ä½¿ç”¨PBCç‰¹æ®Šæºï¼ˆç›¸ä½ä¿®æ­£ï¼‰")
    print("      æ‚¨çš„å¯¦ç¾: ä½¿ç”¨æ¨™æº–æº")
else:
    print("   âœ… ä½¿ç”¨è¤‡æ•¸å¹³é¢æ³¢æº")

# å·®ç•°2: å ´æ›´æ–°æ–¹ç¨‹
if not has_bloch and not has_periodic:
    issues.append("âŒ ç¼ºå°‘é€±æœŸé‚Šç•Œæ¢ä»¶")
    print("   âŒ é‚Šç•Œæ¢ä»¶å·®ç•°:")
    print("      MATLAB: å°ˆé–€çš„PBCæ›´æ–°æ–¹ç¨‹")
    print("      æ‚¨çš„å¯¦ç¾: æ¨™æº–é‚Šç•Œæ¢ä»¶")

# å·®ç•°3: è¤‡æ•¸å ´è™•ç†
E_is_complex = np.iscomplexobj(grid.E)
H_is_complex = np.iscomplexobj(grid.H)

if not (E_is_complex and H_is_complex):
    issues.append("âŒ å ´ä¸æ˜¯è¤‡æ•¸é¡å‹")
    print("   âŒ å ´é¡å‹å·®ç•°:")
    print("      MATLAB: æ‰€æœ‰å ´éƒ½æ˜¯è¤‡æ•¸")
    print(f"      æ‚¨çš„å¯¦ç¾: Eè¤‡æ•¸={E_is_complex}, Hè¤‡æ•¸={H_is_complex}")
else:
    print("   âœ… å ´ç‚ºè¤‡æ•¸é¡å‹")

# === 5. æª¢æ¸¬å™¨å¯¦ç¾æª¢æŸ¥ ===
print(f"\n5. æª¢æ¸¬å™¨å¯¦ç¾æª¢æŸ¥ï¼š")

for i, det in enumerate(grid.detectors):
    det_type = type(det).__name__
    print(f"   æª¢æ¸¬å™¨{i}: {det_type}")
    
    # æª¢æŸ¥æ˜¯å¦æœ‰ç›¸ä½ä¿®æ­£
    has_phase_correction = hasattr(det, 'phase_correction') or hasattr(det, 'spatial_phase')
    print(f"             ç›¸ä½ä¿®æ­£: {has_phase_correction}")
    
    if not has_phase_correction:
        issues.append(f"âŒ æª¢æ¸¬å™¨{i}ç¼ºå°‘ç›¸ä½ä¿®æ­£")

# === 6. æå‡ºä¿®æ­£å»ºè­° ===
print(f"\n6. ä¿®æ­£å»ºè­°ï¼š")
print("   " + "="*50)

if issues:
    print("   ğŸ”§ éœ€è¦ä¿®æ­£çš„å•é¡Œï¼š")
    for issue in issues:
        print(f"      {issue}")
    
    print(f"\n   ğŸ’¡ å…·é«”ä¿®æ­£æ­¥é©Ÿï¼š")
    
    if "âŒ æœªä½¿ç”¨è¤‡æ•¸å¹³é¢æ³¢æº" in str(issues):
        print("      1. ç¢ºä¿ä½¿ç”¨ComplexPlaneWaveæº")
        print("         - è¨­å®šé©ç•¶çš„theta_degåƒæ•¸")
        print("         - ç¢ºä¿amplitudeç‚ºè¤‡æ•¸")
    
    if "âŒ ç¼ºå°‘é€±æœŸé‚Šç•Œæ¢ä»¶" in str(issues):
        print("      2. æ·»åŠ æ­£ç¢ºçš„é€±æœŸé‚Šç•Œæ¢ä»¶ï¼š")
        print("         - ä½¿ç”¨BlochBoundaryè€Œéæ™®é€šPML")
        print("         - è¨­å®šæ­£ç¢ºçš„k_componentåƒæ•¸")
    
    if "âŒ å ´ä¸æ˜¯è¤‡æ•¸é¡å‹" in str(issues):
        print("      3. ç¢ºä¿è¤‡æ•¸å ´è™•ç†ï¼š")
        print("         - Gridåˆå§‹åŒ–æ™‚è¨­å®šforce_complex=True")
        print("         - èª¿ç”¨grid.promote_dtypes_to_complex()")
    
    if any("æª¢æ¸¬å™¨" in issue for issue in issues):
        print("      4. ä¿®æ­£æª¢æ¸¬å™¨å¯¦ç¾ï¼š")
        print("         - æ·»åŠ ç›¸ä½ä¿®æ­£è¨ˆç®—")
        print("         - ä½¿ç”¨è¤‡æ•¸Poyntingå‘é‡è¨ˆç®—")

else:
    print("   âœ… åŸºæœ¬é…ç½®çœ‹èµ·ä¾†æ­£ç¢º")
    print("   ğŸ” å¯èƒ½çš„å•é¡Œåœ¨æ–¼æ•¸å€¼å¯¦ç¾ç´°ç¯€")

return issues
```

def compare_with_analytical_solution():
â€œâ€â€
èˆ‡è§£æè§£å°æ¯”ï¼Œé©—è­‰è¨ˆç®—æ­£ç¢ºæ€§
â€œâ€â€
print(fâ€\n7. è§£æè§£å°æ¯”ï¼šâ€)
print(â€   â€œ + â€œ=â€*30)

```
# Fresnelå…¬å¼ï¼ˆå‚ç›´å…¥å°„ï¼‰
n1, n2 = 1.0, 1.5  # ç©ºæ°£ â†’ ä»‹é›»è³ª

# åå°„ä¿‚æ•¸
r = (n1 - n2) / (n1 + n2)
R_theory = abs(r)**2

# ç©¿é€ä¿‚æ•¸
t = 2*n1 / (n1 + n2)
T_theory = abs(t)**2 * n2/n1  # è€ƒæ…®æŠ˜å°„ç‡å·®ç•°

print(f"   ç†è«–å€¼ï¼ˆå‚ç›´å…¥å°„ï¼‰ï¼š")
print(f"   åå°„ç‡ R = {R_theory:.4f} ({R_theory*100:.1f}%)")
print(f"   ç©¿é€ç‡ T = {T_theory:.4f} ({T_theory*100:.1f}%)")
print(f"   ç¸½å’Œ R+T = {R_theory + T_theory:.4f}")

return R_theory, T_theory
```

def suggest_matlab_style_implementation():
â€œâ€â€
å»ºè­°ç¬¦åˆMATLABç¬¬14ç« é¢¨æ ¼çš„å¯¦ç¾
â€œâ€â€
print(fâ€\n8. MATLABé¢¨æ ¼å¯¦ç¾å»ºè­°ï¼šâ€)
print(â€   â€œ + â€œ=â€*40)

```
print("""
```

ğŸ¯ é—œéµå¯¦ç¾è¦é»ï¼š

1. æºè¨­å®šï¼ˆåƒç…§Listing 14.3ï¼‰ï¼š
   
   ```python
   # è¨­å®šæ°´å¹³æ³¢æ•¸
   kx = 100  # radian/meter
   ky = 0    # radian/meter
   
   # è¨ˆç®—æœ€å°é »ç‡
   f_min = c * sqrt(kx^2 + ky^2) / (2*pi)
   
   # è¨­å®šèª¿åˆ¶é«˜æ–¯æ³¢å½¢
   source = ComplexPlaneWave(
       wavelength=wavelength,
       theta_deg=theta_deg,  # ç”±kx/kyè¨ˆç®—å¾—å‡º
       amplitude=1.0+0j,
       pulse=False
   )
   ```
1. é‚Šç•Œæ¢ä»¶ï¼ˆåƒç…§Section 14.2ï¼‰ï¼š
   
   ```python
   # xæ–¹å‘é€±æœŸé‚Šç•Œ
   grid[0, :, :] = BlochBoundary(k_component=kx, length=Lx)
   
   # zæ–¹å‘å¸æ”¶é‚Šç•Œ
   grid[:, :, :pml_thick] = PML()
   grid[:, :, -pml_thick:] = PML()
   ```
1. å ´æ›´æ–°ï¼ˆåƒç…§Equations 14.9-14.20ï¼‰ï¼š
- æ‰€æœ‰å ´éƒ½å¿…é ˆæ˜¯è¤‡æ•¸
- é‚Šç•Œæ›´æ–°åŒ…å«ç›¸ä½å› å­ exp(Â±j*k*P)
- æª¢æ¸¬å™¨éœ€è¦ç›¸ä½ä¿®æ­£
1. æª¢æ¸¬å™¨ï¼ˆåƒç…§Section 14.4ï¼‰ï¼š
   
   ```python
   # ç›¸ä½ä¿®æ­£ï¼ˆåƒç…§Equation 14.29ï¼‰
   phase_correction = exp(-j*kx*(i-0.5)*dx - j*ky*(j-1)*dy)
   E_corrected = E_raw * phase_correction
   
   # è¨ˆç®—åå°„/ç©¿é€ä¿‚æ•¸
   E_total = average(E_corrected)
   E_incident = (E_total + eta0*H_total*k/kz) / 2
   E_reflected = E_total - E_incident
   Gamma = E_reflected / E_incident
   ```

â€œâ€â€)

def run_complete_diagnosis(grid, grid_spacing):
â€œâ€â€
é‹è¡Œå®Œæ•´è¨ºæ–·
â€œâ€â€
# 1. åŸºæœ¬è¨ºæ–·
issues = diagnose_pbc_implementation(grid, grid_spacing)

```
# 2. è§£æè§£å°æ¯”
R_theory, T_theory = compare_with_analytical_solution()

# 3. å¯¦ç¾å»ºè­°
suggest_matlab_style_implementation()

# 4. ç¸½çµ
print(f"\nğŸ¯ è¨ºæ–·ç¸½çµï¼š")
print("="*50)

if len(issues) == 0:
    print("âœ… é…ç½®åŸºæœ¬æ­£ç¢ºï¼Œå•é¡Œå¯èƒ½åœ¨æ•¸å€¼å¯¦ç¾ç´°ç¯€")
    print("ğŸ” å»ºè­°æª¢æŸ¥ï¼šå ´æ›´æ–°æ–¹ç¨‹ã€ç›¸ä½ä¿®æ­£ã€åŠŸç‡è¨ˆç®—")
elif len(issues) <= 2:
    print("âš ï¸ æœ‰å°‘æ•¸å•é¡Œéœ€è¦ä¿®æ­£")
    print("ğŸ”§ ä¿®æ­£å¾Œæ‡‰è©²èƒ½å¾—åˆ°æ­£ç¢ºçµæœ")
else:
    print("âŒ ç™¼ç¾å¤šå€‹é—œéµå•é¡Œ")
    print("ğŸš¨ éœ€è¦é‡æ–°å¯¦ç¾é—œéµéƒ¨åˆ†")

print(f"\næœ€é‡è¦çš„ä¿®æ­£å„ªå…ˆç´šï¼š")
print("1. ç¢ºä¿ä½¿ç”¨è¤‡æ•¸å ´å’Œé€±æœŸé‚Šç•Œæ¢ä»¶")
print("2. å¯¦ç¾æ­£ç¢ºçš„ç›¸ä½ä¿®æ­£")
print("3. é©—è­‰åŠŸç‡è¨ˆç®—å…¬å¼")

return issues, R_theory, T_theory
```

# === ç°¡åŒ–ç‰ˆè¨ºæ–·å‡½æ•¸ï¼ˆç›´æ¥å¯ç”¨ï¼‰ ===

def quick_diagnosis(grid, grid_spacing):
â€œâ€â€
å¿«é€Ÿè¨ºæ–·æ‚¨ç¾æœ‰çš„FDTDè¨­å®š
â€œâ€â€
print(â€œğŸš¨ å¿«é€ŸFDTDè¨ºæ–·â€)
print(â€=â€*50)

```
# 1. åŸºæœ¬è³‡è¨Š
print(f"1. åŸºæœ¬é…ç½®:")
print(f"   ç¶²æ ¼å½¢ç‹€: {grid.shape}")
print(f"   Grid spacing: {grid_spacing*1e9:.1f} nm")
print(f"   Time step: {grid.time_step:.2e} s")

# 2. å ´é¡å‹æª¢æŸ¥
E_complex = 'complex' in str(grid.E.dtype)
H_complex = 'complex' in str(grid.H.dtype)
print(f"\n2. å ´æ•¸æ“šé¡å‹:")
print(f"   Eå ´è¤‡æ•¸: {E_complex}")
print(f"   Hå ´è¤‡æ•¸: {H_complex}")

# 3. é‚Šç•Œæ¢ä»¶
print(f"\n3. é‚Šç•Œæ¢ä»¶:")
for i, boundary in enumerate(grid.boundaries):
    btype = type(boundary).__name__
    print(f"   é‚Šç•Œ{i}: {btype}")
    if 'Bloch' in btype:
        print(f"           k_component: {getattr(boundary, 'k_component', 'N/A')}")
        print(f"           length: {getattr(boundary, 'length', 'N/A')}")

# 4. æºæª¢æŸ¥
print(f"\n4. æºé…ç½®:")
for i, source in enumerate(grid.sources):
    stype = type(source).__name__
    print(f"   æº{i}: {stype}")
    if hasattr(source, 'theta_deg'):
        print(f"         è§’åº¦: {source.theta_deg}Â°")
    if hasattr(source, 'amplitude'):
        print(f"         æŒ¯å¹…: {source.amplitude}")

# 5. æª¢æ¸¬å™¨
print(f"\n5. æª¢æ¸¬å™¨:")
for i, detector in enumerate(grid.detectors):
    dtype = type(detector).__name__
    print(f"   æª¢æ¸¬å™¨{i}: {dtype}")
    if hasattr(detector, 'flip_sign'):
        print(f"            åå‘: {detector.flip_sign}")

# 6. å ´æ•¸å€¼æª¢æŸ¥
E_max = float(np.max(np.abs(grid.E)))
H_max = float(np.max(np.abs(grid.H)))
print(f"\n6. å ´å¼·åº¦:")
print(f"   |E|_max: {E_max:.3e}")
print(f"   |H|_max: {H_max:.3e}")

if H_max > 1e-15:
    impedance = E_max / H_max
    print(f"   å¯¦éš›é˜»æŠ—: {impedance:.1f} Î©")
    print(f"   ç†è«–é˜»æŠ—: 377 Î©")
    if abs(impedance - 377) > 100:
        print("   âŒ é˜»æŠ—åš´é‡åé›¢ï¼")
    else:
        print("   âœ… é˜»æŠ—åˆç†")
else:
    print("   âŒ Hå ´ç‚ºé›¶ï¼")

# 7. ä¸»è¦å•é¡Œè­˜åˆ¥
print(f"\nğŸ¯ ä¸»è¦å•é¡Œ:")
issues = []

if not (E_complex and H_complex):
    issues.append("âŒ å ´ä¸æ˜¯è¤‡æ•¸é¡å‹")

if not any('Bloch' in type(b).__name__ for b in grid.boundaries):
    issues.append("âŒ ç¼ºå°‘BlochBoundary")

if H_max < 1e-15:
    issues.append("âŒ ç£å ´ç‚ºé›¶")
elif abs(E_max/H_max - 377) > 100:
    issues.append("âŒ é˜»æŠ—ç•°å¸¸")

if len(issues) == 0:
    print("   âœ… åŸºæœ¬é…ç½®æ­£ç¢º")
else:
    for issue in issues:
        print(f"   {issue}")

return issues
```

# ä½¿ç”¨ç¤ºä¾‹

def example_usage():
â€œâ€â€
åœ¨æ‚¨çš„test_bloch_PW_xz4.pyä¸­æ·»åŠ é€™å¹¾è¡Œï¼š
â€œâ€â€
print(â€\nâ€ + â€œ=â€*60)
print(â€œğŸ“‹ ä½¿ç”¨æ–¹æ³•ï¼šâ€)
print(â€œåœ¨æ‚¨çš„ä»£ç¢¼ä¸­æ·»åŠ ä»¥ä¸‹å…§å®¹ï¼šâ€)
print(â€â€â€

# åœ¨æ¨¡æ“¬é‹è¡Œå¾Œæ·»åŠ è¨ºæ–·

if **name** == â€œ**main**â€:
try:
results, grid = run_simulation(with_structure=True, total_steps=600)

```
    # ğŸ” æ·»åŠ è¨ºæ–·
    issues = quick_diagnosis(grid, grid_spacing)
    
    # å¦‚æœæœ‰å•é¡Œï¼Œå…ˆä¿®æ­£å†ç¹¼çºŒåˆ†æ
    if issues:
        print("âš ï¸ ç™¼ç¾å•é¡Œï¼Œéœ€è¦ä¿®æ­£ï¼")
    else:
        # ç¹¼çºŒæ‚¨çš„åŸå§‹åˆ†æ
        P_incident = grid.source.get_source_power(grid_spacing=grid_spacing)
        # ...
except Exception as e:
    print(f"éŒ¯èª¤: {e}")
""")
```

# å¦‚æœç›´æ¥é‹è¡Œæ­¤æª”æ¡ˆ

if **name** == â€œ**main**â€:
print(â€œFDTDé€±æœŸé‚Šç•Œæ¢ä»¶è¨ºæ–·å·¥å…·â€)
example_usage()