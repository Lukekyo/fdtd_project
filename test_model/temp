# Visualization.py

import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as ptc
from matplotlib.colors import LogNorm
from tqdm import tqdm
from numpy import log10, where
from scipy.signal import hilbert

from .backend import backend as bd

def visualize(
    grid, x=None, y=None, z=None,
    cmap="Blues",
    pbcolor="C3", pmlcolor=(0,0,0,0.1),
    objcolor=(1,0,0,0.1),
    blochcolor=(0.6,0.4,0.9,0.8),
    srccolor="C0", detcolor="C2",
    norm="linear",
    animate=False, index=None, save=False, folder=None,
    show=False, style=None,
    mode="energy",     # ğŸ”¹æ–°å¢ mode
    real_vmax=1.0      # ğŸ”¹Ex å¯¦éƒ¨ç¯„åœä¸Šé™
):
    """
    mode: 'energy' | 'real' | 'abs'
    """
    if style:
        plt.style.use(style)
    if norm not in ("linear","lin","log"):
        raise ValueError("norm should be linear or log")
    from .sources import PointSource, LineSource, PlaneSource, ComplexLineSource
    from .boundaries import _PeriodicBoundaryX, _PeriodicBoundaryY, _PeriodicBoundaryZ, BlochBoundary
    from .boundaries import (_PMLXlow,_PMLXhigh,_PMLYlow,_PMLYhigh,_PMLZlow,_PMLZhigh)

    if animate:
        plt.pause(0.02)
        plt.clf()
        plt.ion()

    # é©—è­‰è¼¸å…¥
    if sum(v is not None for v in (x,y,z)) != 1:
        raise ValueError("Choose exactly one of x,y,z")

    # legend setup
    plt.plot([], lw=7, color=objcolor, label="Objects")
    plt.plot([], lw=7, color=pmlcolor, label="PML")
    plt.plot([], lw=3, color=pbcolor, label="Periodic Boundaries")
    plt.plot([], lw=3, color=srccolor, label="Sources")
    plt.plot([], lw=3, color=detcolor, label="Detectors")
    plt.plot([], lw=3, color=blochcolor, label="Bloch Boundaries")

    # æŠ•å½±ä½ç½®ã€åº§æ¨™è¨­å®š
    if x is not None:
        projE = grid.E[x,:,:,:]
        xlabel, ylabel, Nx, Ny = "y","z", grid.Ny, grid.Nz
        energy = bd.numpy(bd.sum(grid.E**2+grid.H**2, axis=-1)[x,:,:])
    elif y is not None:
        projE = grid.E[:,y,:,:]
        xlabel, ylabel, Nx, Ny = "z","x", grid.Nz, grid.Nx
        energy = bd.numpy(bd.sum(grid.E**2+grid.H**2, axis=-1)[:,y,:]).T
    else:
        projE = grid.E[:,:,z,:]
        xlabel, ylabel, Nx, Ny = "x","y", grid.Nx, grid.Ny
        energy = bd.numpy(bd.sum(grid.E**2+grid.H**2, axis=-1)[:,:,z])

    # draw sources/detectors/boundaries/objects ...
    # ï¼ˆç•¥â€”èˆ‡åŸ code ç›¸åŒï¼‰

    # === æ ¹æ“š mode æ±ºå®šé¡¯ç¤ºå…§å®¹ ===
    if mode == "energy":
        image = energy
        cmap_used = cmap
        norm_used = LogNorm(vmin=1e-4, vmax=image.max()+1e-4) if norm in ("log","lin","linear") else None
    else:
        # å– Ex åˆ†é‡
        Ex = bd.numpy(projE[...,0])
        if mode == "real":
            image = Ex.real
            cmap_used = "RdBu"
        elif mode == "abs":
            image = np.abs(Ex)
            cmap_used = cmap
        else:
            raise ValueError("mode must be 'energy','real' or 'abs'")
        norm_used = None

    # ç•«åœ–
    plt.imshow(
        image.T,
        cmap=cmap_used,
        norm=norm_used,
        origin="lower",
        vmin=-real_vmax if mode=="real" else None,
        vmax= real_vmax if mode=="real" else None
    )
    plt.colorbar()
    plt.xlabel(xlabel); plt.ylabel(ylabel)
    plt.ylim(Nx,-1); plt.xlim(-1,Ny)
    plt.figlegend(); plt.tight_layout()

    if save and folder and index is not None:
        plt.savefig(os.path.join(folder, f"{mode}_{index:04d}.png"))
    if show:
        plt.show()
    return plt.gcf()


def dB_map_2D( ... ):
    # åŸæœ¬ code ç„¡ä¿®æ”¹
    ...

def plot_detection( ... ):
    # åŸæœ¬ code ç„¡ä¿®æ”¹
    ...