import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(**file**), â€˜..â€™)))
import time
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output
from scipy.ndimage import gaussian_filter1d
import fdtd

# ==== æ¨¡æ“¬åƒæ•¸ ====

fdtd.set_backend(â€œnumpyâ€)
wavelength = fdtd.nm(1550)
grid_spacing = fdtd.nm(20)
x_span, z_span = fdtd.um(2), fdtd.um(6)
Nx = fdtd.to_grid(x_span, grid_spacing)
Nz = fdtd.to_grid(z_span, grid_spacing)
theta_deg = 0
theta = np.deg2rad(theta_deg)
k0 = 2 * np.pi / wavelength
kx = k0 * np.sin(theta)
Lx = Nx * grid_spacing

# ğŸ”§ ä¿®æ­£å¾Œçš„ä½ç½®è¨­å®š

pml_thickness = 10
source_z = pml_thickness + 5       # åœ¨PMLå¾Œé¢ä¸€é»
det_z_R = fdtd.to_grid(fdtd.um(1.5), grid_spacing)  # çµæ§‹å‰é¢
start_z = fdtd.to_grid(fdtd.um(2), grid_spacing)     # çµæ§‹é–‹å§‹
end_z = fdtd.to_grid(fdtd.um(3), grid_spacing)       # çµæ§‹çµæŸ
det_z_T = fdtd.to_grid(fdtd.um(4.5), grid_spacing)  # çµæ§‹å¾Œé¢

print(fâ€ğŸ“ ä½ç½®è¨­å®š:â€)
print(fâ€   Source: z = {source_z} ({source_z * grid_spacing * 1e6:.2f} Î¼m)â€)
print(fâ€   åå°„æ¢æ¸¬å™¨: z = {det_z_R} ({det_z_R * grid_spacing * 1e6:.2f} Î¼m)â€)
print(fâ€   çµæ§‹: z = {start_z}-{end_z} ({start_z * grid_spacing * 1e6:.2f}-{end_z * grid_spacing * 1e6:.2f} Î¼m)â€)
print(fâ€   ç©¿é€æ¢æ¸¬å™¨: z = {det_z_T} ({det_z_T * grid_spacing * 1e6:.2f} Î¼m)â€)

# ==== make_grid å‡½å¼å°è£ ====

def make_grid(with_structure=True):
â€œâ€â€œå‰µå»ºFDTDç¶²æ ¼â€â€â€
grid = fdtd.Grid(
shape=(Nx, 1, Nz),
grid_spacing=grid_spacing,
permittivity=1.0,
force_complex=True  # ğŸ”§ ç¢ºä¿è¤‡æ•¸æ”¯æ´
)

```
# é‚Šç•Œæ¢ä»¶
grid[0, :, :] = fdtd.BlochBoundary(k_component=kx, length=Lx)
grid[:, :, :pml_thickness] = fdtd.PML(name="pml_low")
grid[:, :, -pml_thickness:] = fdtd.PML(name="pml_high")

# æºè¨­å®š
grid[:, 0, source_z] = fdtd.ComplexPlaneWave(
    wavelength=wavelength,
    period=wavelength / 3e8,
    amplitude=1.0 + 0j,
    theta_deg=theta_deg,
    polarization_axis="x",
    pulse=False,
    name="source"
)

# ğŸ”§ ä¿®æ­£å¾Œçš„æ¢æ¸¬å™¨è¨­å®š
grid[:, 0, det_z_T] = fdtd.LineDetector(name="T", flip_sign=False)  # ç©¿é€
grid[:, 0, det_z_R] = fdtd.LineDetector(name="R", flip_sign=True)   # åå°„

simfolder = None
if with_structure:
    # çµæ§‹è¨­å®š
    grid[:, 0, start_z:end_z] = fdtd.Object(n=1.5, k=0, name="structure")
    simfolder = grid.save_simulation("test_bloch_xz")
    
    print(f"âœ… æ·»åŠ çµæ§‹ï¼šn=1.5, åšåº¦={(end_z-start_z)*grid_spacing*1e6:.2f}Î¼m")

return grid, simfolder
```

def calculate_source_power(grid):
â€œâ€â€œè¨ˆç®—å…¥å°„æºåŠŸç‡â€â€â€
source = grid.source
source_length = len(getattr(source, â€˜xâ€™, [1])) * grid_spacing

```
# è‡ªç”±ç©ºé–“é˜»æŠ—å’ŒæŒ¯å¹…
Z0 = 377.0  # Î©
E0 = abs(source.amplitude)

# åŠŸç‡å¯†åº¦å’Œç¸½åŠŸç‡
power_density = 0.5 * E0**2 / Z0
P_incident = power_density * source_length

print(f"ğŸ“Š æºåŠŸç‡è¨ˆç®—:")
print(f"   æŒ¯å¹…: {E0:.3f} V/m")
print(f"   æºé•·åº¦: {source_length*1e6:.2f} Î¼m")
print(f"   å…¥å°„åŠŸç‡: {P_incident:.6e} W/m")

return P_incident
```

def analyze_results(grid, P_incident, stabilization_steps=100):
â€œâ€â€œåˆ†æç©¿é€åå°„çµæœâ€â€â€
print(fâ€\nğŸ“Š çµæœåˆ†æ:â€)

```
# æª¢æŸ¥æ•¸æ“šé•·åº¦
T_data = np.array(grid.T.S)
R_data = np.array(grid.R.S)

print(f"   æ•¸æ“šé•·åº¦: T={len(T_data)}, R={len(R_data)}")

if len(T_data) < stabilization_steps:
    print(f"âš ï¸ è­¦å‘Šï¼šæ•¸æ“šé•·åº¦ä¸è¶³ï¼Œä½¿ç”¨å…¨éƒ¨æ•¸æ“š")
    T_avg = np.mean(T_data)
    R_avg = np.mean(R_data)
else:
    # ä½¿ç”¨æœ€å¾Œstabilization_stepså€‹æ•¸æ“šé»
    T_avg = np.mean(T_data[-stabilization_steps:])
    R_avg = np.mean(R_data[-stabilization_steps:])

# è¨ˆç®—ç©¿é€åå°„ç‡
T_ratio = T_avg / P_incident if P_incident != 0 else 0
R_ratio = abs(R_avg) / P_incident if P_incident != 0 else 0  # åå°„å–çµ•å°å€¼
A_ratio = 1 - T_ratio - R_ratio  # å¸æ”¶ç‡

print(f"   åŸå§‹åŠŸç‡: T={T_avg:.6e}, R={R_avg:.6e}")
print(f"   ç©¿é€ç‡: T = {T_ratio:.3f} ({T_ratio*100:.1f}%)")
print(f"   åå°„ç‡: R = {R_ratio:.3f} ({R_ratio*100:.1f}%)")
print(f"   å¸æ”¶ç‡: A = {A_ratio:.3f} ({A_ratio*100:.1f}%)")
print(f"   èƒ½é‡å®ˆæ†: T+R+A = {T_ratio+R_ratio+A_ratio:.3f}")

return {
    'T': T_ratio,
    'R': R_ratio, 
    'A': A_ratio,
    'T_raw': T_avg,
    'R_raw': R_avg,
    'P_incident': P_incident
}
```

def run_simulation(with_structure=True, total_steps=500, animation_interval=50):
â€œâ€â€œé‹è¡Œå®Œæ•´æ¨¡æ“¬â€â€â€
print(fâ€\nğŸš€ é–‹å§‹æ¨¡æ“¬ ({â€˜æœ‰çµæ§‹â€™ if with_structure else â€˜ç„¡çµæ§‹â€™})â€)
print(â€=â€ * 60)

```
# å‰µå»ºç¶²æ ¼
grid, simfolder = make_grid(with_structure=with_structure)

# è¨ˆç®—æºåŠŸç‡
P_incident = calculate_source_power(grid)

# é‹è¡Œæ¨¡æ“¬
print(f"\nâš¡ åŸ·è¡Œ {total_steps} å€‹æ™‚é–“æ­¥...")
simulation_start = time.time()

for t in range(total_steps):
    grid.step()
    
    # å‹•ç•«é¡¯ç¤ºï¼ˆå¯é¸ï¼‰
    if simfolder and t % animation_interval == 0:
        try:
            fig = grid.visualize(
                y=0, 
                animate=True, 
                index=t, 
                save=True, 
                folder=simfolder, 
                real_field_mode=True, 
                real_component="Ex"
            )
            plt.title(f"t = {t} / {total_steps}")
            ax = plt.gca()
            ax.set_xlabel("x (Î¼m)")
            ax.set_ylabel("z (Î¼m)")
            plt.tight_layout()
            clear_output(wait=True)
        except Exception as e:
            print(f"âš ï¸ å¯è¦–åŒ–éŒ¯èª¤: {e}")
    
    # é€²åº¦é¡¯ç¤º
    if t % 50 == 0:
        elapsed = time.time() - simulation_start
        if t > 0:
            eta = elapsed * (total_steps - t) / t
            print(f"   é€²åº¦: {t:3d}/{total_steps} ({t/total_steps*100:5.1f}%) - å·²ç”¨{elapsed:.1f}s, å‰©é¤˜{eta:.1f}s")

simulation_time = time.time() - simulation_start
print(f"âœ… æ¨¡æ“¬å®Œæˆï¼è€—æ™‚: {simulation_time:.1f} ç§’")

# åˆ†æçµæœ
results = analyze_results(grid, P_incident)

return results
```

# ==== ä¸»ç¨‹å¼åŸ·è¡Œ ====

if **name** == â€œ**main**â€:
print(â€œğŸ”¬ FDTD ç©¿é€åå°„ç‡è¨ˆç®—â€)
print(â€=â€ * 60)

```
try:
    # ğŸ”§ æ–¹æ³•1ï¼šåƒè€ƒé‹è¡Œï¼ˆå¦‚æœfdtd.reference_runå¯ç”¨ï¼‰
    try:
        print("\nğŸ“Š æ­¥é©Ÿ1ï¼šåƒè€ƒé‹è¡Œï¼ˆç„¡çµæ§‹ï¼‰")
        ref_result = fdtd.reference_run(grid_factory=lambda: make_grid(False), total_steps=500)
        print(f"åƒè€ƒçµæœ: T={ref_result['T']:.6e}, R={ref_result['R']:.6e}")
        
        # æœ‰çµæ§‹çš„æ¨¡æ“¬
        print("\nğŸ“Š æ­¥é©Ÿ2ï¼šæœ‰çµæ§‹æ¨¡æ“¬")
        struct_result = run_simulation(with_structure=True, total_steps=500)
        
        # ç›¸å°æ¯”è¼ƒ
        print(f"\nğŸ“‹ æœ€çµ‚çµæœæ¯”è¼ƒ:")
        print(f"   ç„¡çµæ§‹: T={ref_result['T']:.6e}, R={ref_result['R']:.6e}")
        print(f"   æœ‰çµæ§‹: T={struct_result['T_raw']:.6e}, R={struct_result['R_raw']:.6e}")
        print(f"   æ­¸ä¸€åŒ–: T={struct_result['T']:.3f}, R={struct_result['R']:.3f}")
        
    except (AttributeError, NameError):
        print("âš ï¸ reference_run ä¸å¯ç”¨ï¼Œæ”¹ç”¨å–®æ¬¡æ¨¡æ“¬")
        
        # ğŸ”§ æ–¹æ³•2ï¼šå–®æ¬¡æ¨¡æ“¬
        results = run_simulation(with_structure=True, total_steps=800)
        
        print(f"\nğŸ“‹ æœ€çµ‚çµæœ:")
        print(f"   ç©¿é€ç‡: T = {results['T']:.3f} ({results['T']*100:.1f}%)")
        print(f"   åå°„ç‡: R = {results['R']:.3f} ({results['R']*100:.1f}%)")
        print(f"   å¸æ”¶ç‡: A = {results['A']:.3f} ({results['A']*100:.1f}%)")
        
        # ğŸ”§ ç†è«–æ¯”è¼ƒï¼ˆFresnelå…¬å¼ï¼‰
        n1, n2 = 1.0, 1.5  # çœŸç©º â†’ ä»‹é›»ææ–™
        r_theory = ((n1 - n2) / (n1 + n2))**2
        t_theory = 4*n1*n2 / (n1 + n2)**2
        
        print(f"\nğŸ§® ç†è«–æ¯”è¼ƒï¼ˆFresnelå…¬å¼ï¼‰:")
        print(f"   ç†è«–åå°„ç‡: R = {r_theory:.3f}")
        print(f"   ç†è«–ç©¿é€ç‡: T = {t_theory:.3f}")
        print(f"   å·®ç•°: Î”R = {abs(results['R'] - r_theory):.3f}, Î”T = {abs(results['T'] - t_theory):.3f}")

except Exception as e:
    print(f"\nğŸ’¥ ç¨‹å¼åŸ·è¡ŒéŒ¯èª¤: {e}")
    import traceback
    traceback.print_exc()

finally:
    print(f"\nâœ… ç¨‹å¼åŸ·è¡Œå®Œæˆ")
```