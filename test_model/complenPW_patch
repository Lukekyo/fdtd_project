class ComplexPlaneWave:
â€œâ€â€œA 2D plane wave source following Lumericalâ€™s approach: always pulse, extract frequency via FFTâ€â€â€

```
def __init__(
    self,
    # ä¸»è¦åƒæ•¸ - å®Œå…¨æ¨¡ä»¿ Lumerical çš„ä»‹é¢
    wavelength_min: float,
    wavelength_max: float,
    
    # å…¶ä»–åƒæ•¸
    amplitude: complex = 1.0 + 0.0j,
    phase_shift: float = 0.0,
    theta_deg: float = 0.0,
    polarization_axis: str = "x",
    name: str = None,
    
    # é€²éšé¸é …
    optimize_for_short_pulse: bool = True,  # æ¨¡ä»¿ Lumerical çš„è¨­å®š
    medium_n: float = None
):
    """
    å‰µå»ºComplexPlaneWaveï¼Œå®Œå…¨æ¨¡ä»¿ Lumerical çš„åšæ³•ï¼š
    - ç¸½æ˜¯ä½¿ç”¨è„ˆè¡ï¼ˆä¸ç®¡å–®é »æˆ–å¯¬é »ï¼‰
    - é€šé FFT æå–æ‰€éœ€é »ç‡çš„éŸ¿æ‡‰
    
    Args:
        wavelength_min: æœ€å°æ³¢é•· (m)
        wavelength_max: æœ€å¤§æ³¢é•· (m)
        optimize_for_short_pulse: æ˜¯å¦å„ªåŒ–çŸ­è„ˆè¡ï¼ˆLumerical é è¨­é–‹å•Ÿï¼‰
        
    æ³¨æ„ï¼š
        - ä¸ç®¡ wavelength_min æ˜¯å¦ç­‰æ–¼ wavelength_maxï¼Œéƒ½ç”¨è„ˆè¡
        - å–®é »æ™‚ï¼šè„ˆè¡è¦†è“‹è©²é »ç‡ï¼ŒFFT æå–å–®é »éŸ¿æ‡‰
        - å¯¬é »æ™‚ï¼šè„ˆè¡è¦†è“‹æ•´å€‹é »ç‡ç¯„åœï¼ŒFFT æå–å¯¬é »éŸ¿æ‡‰
    """
    
    # é©—è­‰è¼¸å…¥
    if wavelength_min <= 0 or wavelength_max <= 0:
        raise ValueError("æ³¢é•·å¿…é ˆå¤§æ–¼ 0")
    if wavelength_min > wavelength_max:
        raise ValueError("wavelength_min ä¸èƒ½å¤§æ–¼ wavelength_max")
    
    # åŸºæœ¬åƒæ•¸
    self.wavelength_min = wavelength_min
    self.wavelength_max = wavelength_max
    self.wavelength_center = (wavelength_min + wavelength_max) / 2
    self.wavelength_span = wavelength_max - wavelength_min
    
    self.amplitude = amplitude
    self.phase_shift = phase_shift
    self.theta_deg = theta_deg
    self.theta = bd.deg2rad(theta_deg)
    self.polarization_axis = polarization_axis.lower()
    self.name = name
    self.n = medium_n if medium_n is not None else 1.0
    self.optimize_for_short_pulse = optimize_for_short_pulse
    
    # åˆ¤æ–·æ˜¯å¦ç‚ºå–®é »ï¼ˆä½†éƒ½ç”¨è„ˆè¡ï¼ï¼‰
    tolerance = 1e-12  # æµ®é»æ•¸æ¯”è¼ƒå®¹å·®
    self.is_single_frequency = abs(wavelength_max - wavelength_min) < tolerance
    
    # é »ç‡åƒæ•¸è¨ˆç®—
    self.frequency_center = bd.c0 / self.n / self.wavelength_center
    self.frequency_min = bd.c0 / self.n / wavelength_max  # æ³¨æ„åå‘
    self.frequency_max = bd.c0 / self.n / wavelength_min  # æ³¨æ„åå‘
    self.frequency = self.frequency_center
    
    self.period = 1.0 / self.frequency
    self.omega = 2 * bd.pi * self.frequency
    self.k = 2 * np.pi / self.wavelength_center
    
    # è¨ˆç®—é »è­œç‰¹æ€§
    self.frequency_bandwidth = self.frequency_max - self.frequency_min
    self.relative_bandwidth = self.wavelength_span / self.wavelength_center if self.wavelength_center > 0 else 0
    
    # Lumerical é¢¨æ ¼çš„è„ˆè¡åƒæ•¸è¨­å®š
    self._setup_lumerical_pulse_parameters()
    
    # ç¸½æ˜¯ä½¿ç”¨è„ˆè¡ï¼
    self.pulse = True
    self.source_type = "lumerical_style_pulse"
    
    # åˆå§‹åŒ–å…¶ä»–å±¬æ€§
    self.grid = None
    self.period_sim = None
    self.frequency_sim = None
    self.omega_sim = None
    self.hanning_dt_sim = None
    self.monitoring_enabled = False
    self.monitor_data = {
        'timesteps': [],
        'E_field': [],
        'envelope': [],
        'phase': []
    }

def _setup_lumerical_pulse_parameters(self):
    """è¨­å®š Lumerical é¢¨æ ¼çš„è„ˆè¡åƒæ•¸ï¼ˆåŸºæ–¼åœ–ç‰‡è§€å¯Ÿï¼‰"""
    
    if self.is_single_frequency:
        # å–®é »ï¼šä½¿ç”¨è¼ƒé•·çš„è„ˆè¡ï¼Œçœ‹èµ·ä¾†åƒå¹³å°ä½†ä»æ˜¯è„ˆè¡
        # å¾åœ–ç‰‡ï¼šå–®é »ç”¨ 6.47 fsï¼Œå¯¬é »ç”¨ 3.32 fs
        if self.optimize_for_short_pulse:
            self.cycle = 8  # è¼ƒé•·ï¼Œç”¢ç”Ÿçª„é »è­œ
            self.pulse_type = "standard_single_freq"
        else:
            self.cycle = 12  # æ›´é•·ï¼Œæ›´ç²¾ç¢ºçš„é »ç‡
            self.pulse_type = "long_single_freq"
            
    else:
        # å¯¬é »ï¼šä½¿ç”¨è¼ƒçŸ­çš„è„ˆè¡ï¼Œæ˜é¡¯çš„åŒ…çµ¡å½¢ç‹€
        # å¾åœ–ç‰‡ï¼šå¯¬é »ç”¨çŸ­è„ˆè¡ç”¢ç”Ÿå¯¬é »è­œ
        if self.optimize_for_short_pulse:
            # çŸ­è„ˆè¡ï¼Œé¡ä¼¼åœ–1ä¸­çš„ "broadband" è¨­å®š
            self.cycle = max(2, min(4, int(1.0 / max(self.relative_bandwidth, 0.1))))
            self.pulse_type = "broadband_short"
        else:
            # ç¨é•·ä½†ä»ä¿æŒå¯¬é »ç‰¹æ€§
            self.cycle = max(3, min(8, int(1.5 / max(self.relative_bandwidth, 0.05))))
            self.pulse_type = "broadband_medium"
    
    # è¨ˆç®—è„ˆè¡ç›¸é—œåƒæ•¸ï¼ˆæ¨¡ä»¿ Lumerical çš„è¨ˆç®—ï¼‰
    self._calculate_pulse_spectrum()

def _calculate_pulse_spectrum(self):
    """è¨ˆç®—è„ˆè¡çš„é »è­œç‰¹æ€§ï¼ˆæ¨¡ä»¿ Lumerical çš„åˆ†æï¼‰"""
    
    # è„ˆè¡æŒçºŒæ™‚é–“ï¼ˆä»¥é€±æœŸç‚ºå–®ä½ï¼‰
    self.pulse_duration_periods = self.cycle
    self.pulse_duration_time = self.cycle * self.period
    
    # è„ˆè¡çš„é »è­œå¯¬åº¦ï¼ˆè¿‘ä¼¼ï¼‰
    # å°æ–¼ Hanning çª—ï¼Œä¸»ç“£å¯¬åº¦ç´„ç‚º 2/cycle å€çš„ä¸­å¿ƒé »ç‡
    self.pulse_spectral_width = 2 * self.frequency / self.cycle
    
    # è¨ˆç®—è„ˆè¡è¦†è“‹çš„æœ‰æ•ˆé »ç‡ç¯„åœ
    f_pulse_min = self.frequency - self.pulse_spectral_width / 2
    f_pulse_max = self.frequency + self.pulse_spectral_width / 2
    
    self.pulse_freq_min = max(0, f_pulse_min)
    self.pulse_freq_max = f_pulse_max
    
    # æª¢æŸ¥è„ˆè¡æ˜¯å¦è¦†è“‹æ‰€éœ€çš„é »ç‡ç¯„åœ
    self.frequency_coverage = {
        'target_min': self.frequency_min,
        'target_max': self.frequency_max,
        'pulse_min': self.pulse_freq_min,
        'pulse_max': self.pulse_freq_max,
        'coverage_ok': (self.pulse_freq_min <= self.frequency_min and 
                       self.pulse_freq_max >= self.frequency_max)
    }

def get_spectrum_info(self):
    """è¿”å›è©³ç´°çš„é »è­œè³‡è¨Š"""
    return {
        'source_approach': 'lumerical_style_always_pulse',
        'is_single_frequency': self.is_single_frequency,
        'optimization': 'short_pulse' if self.optimize_for_short_pulse else 'longer_pulse',
        
        # ç›®æ¨™é »è­œ
        'target_wavelength_min_nm': self.wavelength_min * 1e9,
        'target_wavelength_max_nm': self.wavelength_max * 1e9,
        'target_wavelength_center_nm': self.wavelength_center * 1e9,
        'target_frequency_min_THz': self.frequency_min / 1e12,
        'target_frequency_max_THz': self.frequency_max / 1e12,
        'target_frequency_center_THz': self.frequency_center / 1e12,
        'target_bandwidth_THz': self.frequency_bandwidth / 1e12,
        'relative_bandwidth_percent': self.relative_bandwidth * 100,
        
        # è„ˆè¡ç‰¹æ€§
        'pulse_type': self.pulse_type,
        'pulse_cycles': self.cycle,
        'pulse_duration_ps': self.pulse_duration_time * 1e12,
        'pulse_spectral_width_THz': self.pulse_spectral_width / 1e12,
        'pulse_freq_range_THz': [self.pulse_freq_min / 1e12, self.pulse_freq_max / 1e12],
        
        # è¦†è“‹æª¢æŸ¥
        'frequency_coverage': self.frequency_coverage
    }

def print_spectrum_info(self):
    """åˆ—å°é »è­œè³‡è¨Šï¼Œæ¨¡ä»¿ Lumerical çš„é¡¯ç¤ºé¢¨æ ¼"""
    info = self.get_spectrum_info()
    
    print(f"ğŸ“Š Source: {self.name or 'ComplexPlaneWave'}")
    print(f"   Approach: Lumerical-style (always pulse + FFT)")
    print(f"   Type: {'Single Frequency' if info['is_single_frequency'] else 'Broadband'}")
    print(f"   Optimization: {'Short pulse' if self.optimize_for_short_pulse else 'Longer pulse'}")
    print()
    
    print("ğŸ¯ Target Spectrum:")
    if info['is_single_frequency']:
        print(f"   Wavelength: {info['target_wavelength_center_nm']:.1f} nm")
        print(f"   Frequency: {info['target_frequency_center_THz']:.2f} THz")
    else:
        print(f"   Wavelength: {info['target_wavelength_min_nm']:.1f} - {info['target_wavelength_max_nm']:.1f} nm")
        print(f"   Frequency: {info['target_frequency_min_THz']:.2f} - {info['target_frequency_max_THz']:.2f} THz")
        print(f"   Bandwidth: {info['target_bandwidth_THz']:.2f} THz ({info['relative_bandwidth_percent']:.1f}%)")
    print()
    
    print("âš¡ Pulse Characteristics:")
    print(f"   Type: {info['pulse_type']}")
    print(f"   Cycles: {info['pulse_cycles']}")
    print(f"   Duration: {info['pulse_duration_ps']:.1f} ps")
    print(f"   Spectral width: {info['pulse_spectral_width_THz']:.2f} THz")
    print(f"   Pulse freq range: {info['pulse_freq_range_THz'][0]:.2f} - {info['pulse_freq_range_THz'][1]:.2f} THz")
    print()
    
    print("âœ… Coverage Check:")
    coverage = info['frequency_coverage']
    if coverage['coverage_ok']:
        print("   âœ… Pulse spectrum covers target frequency range")
    else:
        print("   âš ï¸ Pulse spectrum may not fully cover target range")
        print(f"      Target: {coverage['target_min']/1e12:.2f} - {coverage['target_max']/1e12:.2f} THz")
        print(f"      Pulse:  {coverage['pulse_min']/1e12:.2f} - {coverage['pulse_max']/1e12:.2f} THz")
    print()
    
    print("ğŸ”„ Post-processing:")
    if info['is_single_frequency']:
        print(f"   FFT will extract response at {info['target_frequency_center_THz']:.2f} THz")
    else:
        print(f"   FFT will extract response over {info['target_frequency_min_THz']:.2f} - {info['target_frequency_max_THz']:.2f} THz")

def explain_lumerical_approach(self):
    """è§£é‡‹ Lumerical çš„æ–¹æ³•"""
    print("ğŸ§  Why Lumerical Always Uses Pulses:")
    print("   1. æ•ˆç‡ï¼šä¸€æ¬¡è„ˆè¡æ¨¡æ“¬å¯ç²å¾—å¤šé »ç‡éŸ¿æ‡‰")
    print("   2. éˆæ´»ï¼šåŒæ¨£çš„æ™‚åŸŸæ•¸æ“šå¯æå–ä»»æ„é »ç‡")
    print("   3. ç©©æ…‹ï¼šé€šé FFT å¾—åˆ°çœŸæ­£çš„ CW ç©©æ…‹éŸ¿æ‡‰")
    print("   4. ä¸€è‡´æ€§ï¼šçµ±ä¸€çš„è™•ç†æµç¨‹ï¼Œæ¸›å°‘éŒ¯èª¤")
    print()
    print("ğŸ“Š Single Frequency çš„ç§˜å¯† (å¾åœ–ç‰‡è­‰å¯¦):")
    print("   - è¡¨é¢ä¸Šï¼šwavelength_min = wavelength_max (å¦‚ 0.98-0.98 Î¼m)")
    print("   - å¯¦éš›ä¸Šï¼špulse type ä»é¡¯ç¤º 'standard'ï¼Œä¸æ˜¯ CWï¼")
    print("   - è„ˆè¡é•·åº¦ï¼šè¼ƒé•·è„ˆè¡ (6.47 fs vs 3.32 fs)")
    print("   - æ™‚åŸŸä¿¡è™Ÿï¼šçœ‹èµ·ä¾†åƒå¹³å°ï¼Œä½†ä»æ˜¯æœ‰é™é•·åº¦è„ˆè¡")
    print("   - çµæœï¼šFFT æå–è©²é »ç‡çš„å®Œç¾ CW éŸ¿æ‡‰")
    print()
    print("ğŸµ Broadband vs Single Frequency å·®ç•°:")
    print("   å¯¬é » (0.5-1.2 Î¼m):")
    print("     â€¢ pulse type: 'broadband'")
    print("     â€¢ çŸ­è„ˆè¡ (3.32 fs)ï¼Œæ˜é¡¯åŒ…çµ¡")
    print("     â€¢ å¯¬é »è­œè¦†è“‹")
    print("   å–®é » (0.98-0.98 Î¼m):")
    print("     â€¢ pulse type: 'standard'") 
    print("     â€¢ é•·è„ˆè¡ (6.47 fs)ï¼Œçœ‹ä¼¼å¹³å°")
    print("     â€¢ çª„é »è­œé›†ä¸­")
    print()
    print("ğŸ” é—œéµæ´å¯Ÿï¼š")
    print("   - Lumerical æ°¸é ä¸ç”¨çœŸæ­£çš„ CW")
    print("   - 'single frequency' åªæ˜¯é•·ä¸€é»çš„è„ˆè¡")
    print("   - æ‰€æœ‰ç©©æ…‹çµæœéƒ½ä¾†è‡ªè„ˆè¡+FFT")
```

# ä½¿ç”¨ç¯„ä¾‹

def demonstrate_lumerical_truth():
â€œâ€â€œå±•ç¤º Lumerical çœŸæ­£çš„å·¥ä½œæ–¹å¼â€â€â€

```
print("=== Lumerical çš„çœŸç›¸ï¼šç¸½æ˜¯è„ˆè¡ï¼ ===\n")

# å–®é »è¨­å®šï¼ˆä½†å¯¦éš›æ˜¯è„ˆè¡ï¼‰
print("1. 'Single Frequency' Source (å¯¦éš›ä¸Šæ˜¯è„ˆè¡):")
source1 = ComplexPlaneWave(
    wavelength_min=1550e-9, 
    wavelength_max=1550e-9,  # min = max
    optimize_for_short_pulse=True
)
source1.print_spectrum_info()

# å¯¬é »è¨­å®š
print("\n" + "="*60 + "\n")
print("2. Broadband Source (æ˜é¡¯çš„è„ˆè¡):")
source2 = ComplexPlaneWave(
    wavelength_min=1500e-9, 
    wavelength_max=1600e-9,  # min â‰  max
    optimize_for_short_pulse=True
)
source2.print_spectrum_info()

# è§£é‡‹åŸç†
print("\n" + "="*60 + "\n")
source1.explain_lumerical_approach()
```

if **name** == â€œ**main**â€:
demonstrate_lumerical_truth()